# æ•…éšœæ’é™¤æŒ‡å—

æœ¬æŒ‡å—æä¾›ç³»ç»Ÿæ€§çš„æ•…éšœæ’é™¤æ–¹æ³•ï¼Œå¸®åŠ©æ‚¨å¿«é€Ÿè¯Šæ–­å’Œè§£å†³TradeMaster Web Interfaceä½¿ç”¨è¿‡ç¨‹ä¸­é‡åˆ°çš„å„ç§é—®é¢˜ã€‚

## ğŸ“‹ ç›®å½•

- [æ•…éšœæ’é™¤æµç¨‹](#æ•…éšœæ’é™¤æµç¨‹)
- [ç³»ç»Ÿè¿æ¥é—®é¢˜](#ç³»ç»Ÿè¿æ¥é—®é¢˜)
- [ç™»å½•è®¤è¯æ•…éšœ](#ç™»å½•è®¤è¯æ•…éšœ)  
- [åŠŸèƒ½æ¨¡å—æ•…éšœ](#åŠŸèƒ½æ¨¡å—æ•…éšœ)
- [æ€§èƒ½é—®é¢˜è¯Šæ–­](#æ€§èƒ½é—®é¢˜è¯Šæ–­)
- [æ•°æ®ç›¸å…³æ•…éšœ](#æ•°æ®ç›¸å…³æ•…éšœ)
- [APIæ¥å£æ•…éšœ](#apiæ¥å£æ•…éšœ)
- [éƒ¨ç½²è¿ç»´æ•…éšœ](#éƒ¨ç½²è¿ç»´æ•…éšœ)
- [æµè§ˆå™¨ç›¸å…³é—®é¢˜](#æµè§ˆå™¨ç›¸å…³é—®é¢˜)
- [ç½‘ç»œè¿æ¥é—®é¢˜](#ç½‘ç»œè¿æ¥é—®é¢˜)

---

## æ•…éšœæ’é™¤æµç¨‹

### ğŸ” æ ‡å‡†è¯Šæ–­æµç¨‹

```yaml
æ•…éšœæ’é™¤æ­¥éª¤:

ç¬¬ä¸€æ­¥ - é—®é¢˜ç¡®è®¤:
  âœ… è¯¦ç»†æè¿°é—®é¢˜ç°è±¡
  âœ… è®°å½•é”™è¯¯ä¿¡æ¯å’Œä»£ç 
  âœ… ç¡®è®¤é—®é¢˜é‡ç°æ­¥éª¤
  âœ… æ”¶é›†ç¯å¢ƒä¿¡æ¯

ç¬¬äºŒæ­¥ - åŸºç¡€æ£€æŸ¥:
  âœ… ç½‘ç»œè¿æ¥çŠ¶æ€
  âœ… æµè§ˆå™¨ç‰ˆæœ¬å…¼å®¹æ€§
  âœ… è´¦æˆ·æƒé™çŠ¶æ€
  âœ… ç³»ç»ŸæœåŠ¡çŠ¶æ€

ç¬¬ä¸‰æ­¥ - æ·±åº¦è¯Šæ–­:
  âœ… æ—¥å¿—æ–‡ä»¶åˆ†æ
  âœ… ç³»ç»Ÿèµ„æºæ£€æŸ¥
  âœ… é…ç½®æ–‡ä»¶éªŒè¯
  âœ… ä¾èµ–æœåŠ¡æ£€æŸ¥

ç¬¬å››æ­¥ - è§£å†³æ–¹æ¡ˆ:
  âœ… å°è¯•æ ‡å‡†è§£å†³æ–¹æ¡ˆ
  âœ… åº”ç”¨é’ˆå¯¹æ€§ä¿®å¤
  âœ… éªŒè¯ä¿®å¤æ•ˆæœ
  âœ… è®°å½•è§£å†³è¿‡ç¨‹
```

### ğŸ“Š é—®é¢˜åˆ†ç±»çŸ©é˜µ

```yaml
é—®é¢˜ä¸¥é‡ç¨‹åº¦åˆ†ç±»:

P0 - ç³»ç»Ÿçº§æ•…éšœ:
  - ç³»ç»Ÿå®Œå…¨ä¸å¯è®¿é—®
  - æ•°æ®ä¸¢å¤±æˆ–æŸå
  - å®‰å…¨æ¼æ´è¢«åˆ©ç”¨
  - å½±å“æ‰€æœ‰ç”¨æˆ·

P1 - åŠŸèƒ½çº§æ•…éšœ:
  - æ ¸å¿ƒåŠŸèƒ½ä¸å¯ç”¨
  - å¤§é‡ç”¨æˆ·å—å½±å“
  - æ•°æ®åŒæ­¥å¼‚å¸¸
  - APIæœåŠ¡ä¸­æ–­

P2 - ä½“éªŒçº§æ•…éšœ:
  - éƒ¨åˆ†åŠŸèƒ½å¼‚å¸¸
  - æ€§èƒ½æ˜æ˜¾ä¸‹é™
  - ç•Œé¢æ˜¾ç¤ºé”™è¯¯
  - å°‘æ•°ç”¨æˆ·å—å½±å“

P3 - è½»å¾®æ•…éšœ:
  - ç•Œé¢å°é”™è¯¯
  - éå…³é”®åŠŸèƒ½å¼‚å¸¸
  - æ–‡æ¡£ä¸å‡†ç¡®
  - ä¸ªåˆ«ç”¨æˆ·åé¦ˆ
```

---

## ç³»ç»Ÿè¿æ¥é—®é¢˜

### ğŸŒ æ— æ³•è®¿é—®ç³»ç»Ÿ

**ç—‡çŠ¶æè¿°ï¼š**
- æµè§ˆå™¨æ˜¾ç¤º"æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨"
- é¡µé¢åŠ è½½è¶…æ—¶
- DNSè§£æå¤±è´¥

**è¯Šæ–­æ­¥éª¤ï¼š**

```bash
# 1. ç½‘ç»œè¿é€šæ€§æµ‹è¯•
ping trademaster.ai
ping 8.8.8.8

# 2. DNSè§£ææµ‹è¯•
nslookup trademaster.ai
dig trademaster.ai

# 3. ç«¯å£è¿é€šæ€§æµ‹è¯•
telnet trademaster.ai 443
nc -zv trademaster.ai 443

# 4. è·¯ç”±è·Ÿè¸ª
traceroute trademaster.ai
tracert trademaster.ai  # Windows
```

**è§£å†³æ–¹æ¡ˆï¼š**

```yaml
ç½‘ç»œé—®é¢˜è§£å†³:

DNSé—®é¢˜:
  1. æ¸…é™¤DNSç¼“å­˜: ipconfig /flushdns
  2. æ›´æ¢DNSæœåŠ¡å™¨: 8.8.8.8, 1.1.1.1
  3. æ£€æŸ¥hostsæ–‡ä»¶é…ç½®
  4. é‡å¯ç½‘ç»œé€‚é…å™¨

é˜²ç«å¢™é—®é¢˜:
  1. ä¸´æ—¶å…³é—­é˜²ç«å¢™æµ‹è¯•
  2. æ·»åŠ ç¨‹åºåˆ°ç™½åå•
  3. å¼€æ”¾å¿…è¦ç«¯å£: 80, 443
  4. æ£€æŸ¥ä¼ä¸šç½‘ç»œç­–ç•¥

ä»£ç†é—®é¢˜:
  1. ç¦ç”¨æµè§ˆå™¨ä»£ç†è®¾ç½®
  2. æ£€æŸ¥ç³»ç»Ÿä»£ç†é…ç½®
  3. ç»•è¿‡ä¼ä¸šä»£ç†æµ‹è¯•
  4. é…ç½®PACæ–‡ä»¶
```

### ğŸ”’ SSLè¯ä¹¦é”™è¯¯

**ç—‡çŠ¶æè¿°ï¼š**
- "æ‚¨çš„è¿æ¥ä¸æ˜¯ç§å¯†è¿æ¥"
- "è¯ä¹¦æ— æ•ˆ"é”™è¯¯
- HTTPSè¿æ¥å¤±è´¥

**è¯Šæ–­å‘½ä»¤ï¼š**

```bash
# SSLè¯ä¹¦æ£€æŸ¥
openssl s_client -connect trademaster.ai:443 -servername trademaster.ai

# è¯ä¹¦è¯¦ç»†ä¿¡æ¯
echo | openssl s_client -connect trademaster.ai:443 2>/dev/null | openssl x509 -noout -dates -subject -issuer

# è¯ä¹¦é“¾éªŒè¯
curl -I https://trademaster.ai
```

**è§£å†³æ–¹æ¡ˆï¼š**

```yaml
SSLè¯ä¹¦é—®é¢˜è§£å†³:

è¯ä¹¦è¿‡æœŸ:
  1. è”ç³»ç®¡ç†å‘˜æ›´æ–°è¯ä¹¦
  2. ä¸´æ—¶æ¥å—é£é™©ç»§ç»­ï¼ˆä»…æµ‹è¯•ç¯å¢ƒï¼‰
  3. ç­‰å¾…è¯ä¹¦è‡ªåŠ¨æ›´æ–°

è¯ä¹¦ä¸åŒ¹é…:
  1. æ£€æŸ¥è®¿é—®åŸŸåæ˜¯å¦æ­£ç¡®
  2. ä½¿ç”¨æ­£ç¡®çš„åŸŸåè®¿é—®
  3. è”ç³»ç®¡ç†å‘˜ç¡®è®¤è¯ä¹¦é…ç½®

ä¸­é—´è¯ä¹¦ç¼ºå¤±:
  1. ä¸‹è½½å®Œæ•´è¯ä¹¦é“¾
  2. é…ç½®ä¸­é—´è¯ä¹¦
  3. ä½¿ç”¨åœ¨çº¿SSLæ£€æµ‹å·¥å…·éªŒè¯

æœ¬åœ°æ—¶é—´é”™è¯¯:
  1. åŒæ­¥ç³»ç»Ÿæ—¶é—´: w32tm /resync
  2. æ£€æŸ¥æ—¶åŒºè®¾ç½®
  3. å¯ç”¨è‡ªåŠ¨æ—¶é—´åŒæ­¥
```

---

## ç™»å½•è®¤è¯æ•…éšœ

### ğŸ” ç™»å½•å¤±è´¥

**ç—‡çŠ¶æè¿°ï¼š**
- ç”¨æˆ·åå¯†ç æ­£ç¡®ä½†æ— æ³•ç™»å½•
- ç™»å½•åç«‹å³è·³å›ç™»å½•é¡µ
- æç¤º"è®¤è¯å¤±è´¥"

**è¯Šæ–­æ£€æŸ¥ï¼š**

```javascript
// æµè§ˆå™¨æ§åˆ¶å°æ£€æŸ¥
// 1. æ£€æŸ¥Cookieè®¾ç½®
console.log(document.cookie);

// 2. æ£€æŸ¥æœ¬åœ°å­˜å‚¨
console.log(localStorage);
console.log(sessionStorage);

// 3. æ£€æŸ¥ç½‘ç»œè¯·æ±‚
// æ‰“å¼€å¼€å‘è€…å·¥å…· -> Network -> å°è¯•ç™»å½•
```

**æ•…éšœæ’é™¤ï¼š**

```yaml
ç™»å½•æ•…éšœè§£å†³:

Cookieé—®é¢˜:
  è§£å†³æ–¹æ¡ˆ:
    1. å¯ç”¨æµè§ˆå™¨Cookie: è®¾ç½® -> éšç§å’Œå®‰å…¨ -> Cookie
    2. æ¸…é™¤ç½‘ç«™Cookieå’Œæ•°æ®
    3. æ·»åŠ ç½‘ç«™åˆ°Cookieç™½åå•
    4. ç¦ç”¨ç¬¬ä¸‰æ–¹Cookieé˜»æ­¢

ä¼šè¯è¿‡æœŸ:
  è§£å†³æ–¹æ¡ˆ:
    1. æ£€æŸ¥ç³»ç»Ÿæ—¶é—´æ˜¯å¦æ­£ç¡®
    2. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜å’Œå­˜å‚¨
    3. é‡æ–°æ‰“å¼€æµè§ˆå™¨
    4. è”ç³»ç®¡ç†å‘˜æ£€æŸ¥ä¼šè¯é…ç½®

è´¦æˆ·çŠ¶æ€:
  æ£€æŸ¥é¡¹ç›®:
    1. è´¦æˆ·æ˜¯å¦è¢«é”å®šæˆ–ç¦ç”¨
    2. å¯†ç æ˜¯å¦å·²è¿‡æœŸ
    3. æ˜¯å¦éœ€è¦é‡ç½®å¯†ç 
    4. æƒé™æ˜¯å¦è¢«ä¿®æ”¹

å¤šç‚¹ç™»å½•å†²çª:
  è§£å†³æ–¹æ¡ˆ:
    1. é€€å‡ºå…¶ä»–è®¾å¤‡çš„ç™»å½•
    2. æ¸…é™¤æ‰€æœ‰ä¼šè¯
    3. ä½¿ç”¨"å¼ºåˆ¶ç™»å½•"é€‰é¡¹
    4. è”ç³»ç®¡ç†å‘˜é‡ç½®ä¼šè¯
```

### ğŸ”‘ åŒå› ç´ è®¤è¯é—®é¢˜

**ç—‡çŠ¶æè¿°ï¼š**
- è®¤è¯ç æ— æ•ˆæˆ–è¿‡æœŸ
- æ‰‹æœºä¸¢å¤±æ— æ³•è·å–éªŒè¯ç 
- å¤‡ç”¨æ¢å¤ç ä¸å·¥ä½œ

**åº”æ€¥è§£å†³ï¼š**

```yaml
2FAæ•…éšœæ¢å¤:

éªŒè¯ç é—®é¢˜:
  1. æ£€æŸ¥æ‰‹æœºæ—¶é—´åŒæ­¥
  2. é‡æ–°åŒæ­¥è®¤è¯åº”ç”¨
  3. ä½¿ç”¨å¤‡ç”¨æ¢å¤ç 
  4. è”ç³»ç®¡ç†å‘˜ä¸´æ—¶ç¦ç”¨2FA

åº”ç”¨é—®é¢˜:
  æ¨èè®¤è¯åº”ç”¨:
    - Google Authenticator âœ…
    - Microsoft Authenticator âœ…
    - Authy âœ…
    - 1Password âœ…
  
  é‡æ–°é…ç½®æ­¥éª¤:
    1. ç¦ç”¨å½“å‰2FAï¼ˆéœ€è¦ç®¡ç†å‘˜ï¼‰
    2. é‡æ–°è®¾ç½®2FA
    3. å¤‡ä»½æ–°çš„æ¢å¤ç 
    4. æµ‹è¯•éªŒè¯è¿‡ç¨‹

è®¾å¤‡ä¸¢å¤±:
  åº”æ€¥å¤„ç†:
    1. ç«‹å³è”ç³»ç®¡ç†å‘˜
    2. ä½¿ç”¨å¤‡ç”¨æ¢å¤ç ç™»å½•
    3. é‡æ–°é…ç½®2FAè®¾ç½®
    4. ç”Ÿæˆæ–°çš„å¤‡ç”¨ç 
```

---

## åŠŸèƒ½æ¨¡å—æ•…éšœ

### ğŸ“Š ç­–ç•¥ç®¡ç†æ•…éšœ

**ç­–ç•¥ä¸Šä¼ å¤±è´¥**

**è¯Šæ–­æ­¥éª¤ï¼š**

```python
# ç­–ç•¥æ–‡ä»¶æ£€æŸ¥è„šæœ¬
import os
import zipfile
import ast

def validate_strategy_file(file_path):
    """éªŒè¯ç­–ç•¥æ–‡ä»¶"""
    issues = []
    
    # æ£€æŸ¥æ–‡ä»¶å¤§å°
    file_size = os.path.getsize(file_path)
    if file_size > 50 * 1024 * 1024:  # 50MB
        issues.append(f"æ–‡ä»¶è¿‡å¤§: {file_size/1024/1024:.1f}MB > 50MB")
    
    # æ£€æŸ¥æ–‡ä»¶æ ¼å¼
    ext = os.path.splitext(file_path)[1].lower()
    if ext not in ['.py', '.ipynb', '.zip']:
        issues.append(f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {ext}")
    
    # æ£€æŸ¥Pythonè¯­æ³•
    if ext == '.py':
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            ast.parse(content)
        except SyntaxError as e:
            issues.append(f"Pythonè¯­æ³•é”™è¯¯: {e}")
        except UnicodeDecodeError:
            issues.append("æ–‡ä»¶ç¼–ç é”™è¯¯ï¼Œè¯·ä½¿ç”¨UTF-8ç¼–ç ")
    
    # æ£€æŸ¥ZIPæ–‡ä»¶
    if ext == '.zip':
        try:
            with zipfile.ZipFile(file_path, 'r') as zf:
                zf.testzip()
        except zipfile.BadZipFile:
            issues.append("ZIPæ–‡ä»¶æŸå")
    
    return issues

# ä½¿ç”¨ç¤ºä¾‹
issues = validate_strategy_file('my_strategy.py')
if issues:
    print("å‘ç°é—®é¢˜:")
    for issue in issues:
        print(f"- {issue}")
else:
    print("æ–‡ä»¶éªŒè¯é€šè¿‡")
```

**è§£å†³æ–¹æ¡ˆï¼š**

```yaml
ç­–ç•¥ä¸Šä¼ é—®é¢˜è§£å†³:

æ–‡ä»¶æ ¼å¼é—®é¢˜:
  1. ç¡®ä¿æ–‡ä»¶æ ¼å¼ä¸º .py, .ipynb, .zip
  2. æ£€æŸ¥æ–‡ä»¶ç¼–ç ä¸ºUTF-8
  3. éªŒè¯Pythonè¯­æ³•æ­£ç¡®æ€§
  4. å‹ç¼©æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥

ç½‘ç»œé—®é¢˜:
  1. æ£€æŸ¥ç½‘ç»œè¿æ¥ç¨³å®šæ€§
  2. å°è¯•åˆ†æ®µä¸Šä¼ å¤§æ–‡ä»¶
  3. ä½¿ç”¨æœ‰çº¿ç½‘ç»œè¿æ¥
  4. é¿å¼€ç½‘ç»œé«˜å³°æœŸ

æƒé™é—®é¢˜:
  1. ç¡®è®¤å…·æœ‰ç­–ç•¥ä¸Šä¼ æƒé™
  2. æ£€æŸ¥å­˜å‚¨ç©ºé—´é…é¢
  3. éªŒè¯æ–‡ä»¶ç›®å½•æƒé™
  4. è”ç³»ç®¡ç†å‘˜åˆ†é…æƒé™

æœåŠ¡å™¨é—®é¢˜:
  1. æ£€æŸ¥æœåŠ¡å™¨ç£ç›˜ç©ºé—´
  2. éªŒè¯ä¸Šä¼ æœåŠ¡çŠ¶æ€
  3. æŸ¥çœ‹æœåŠ¡å™¨é”™è¯¯æ—¥å¿—
  4. é‡å¯ç›¸å…³æœåŠ¡
```

### ğŸ“ˆ å›æµ‹å¼•æ“æ•…éšœ

**å›æµ‹ä»»åŠ¡å¤±è´¥æˆ–å¡ä½**

**è¯Šæ–­å·¥å…·ï¼š**

```python
# å›æµ‹çŠ¶æ€ç›‘æ§è„šæœ¬
import requests
import time
import json

def monitor_backtest(task_id, api_key):
    """ç›‘æ§å›æµ‹ä»»åŠ¡çŠ¶æ€"""
    headers = {'Authorization': f'Bearer {api_key}'}
    url = f'https://api.trademaster.ai/v1/backtest/{task_id}'
    
    while True:
        try:
            response = requests.get(url, headers=headers)
            data = response.json()
            
            status = data.get('status')
            progress = data.get('progress', 0)
            
            print(f"çŠ¶æ€: {status}, è¿›åº¦: {progress}%")
            
            if status in ['completed', 'failed', 'cancelled']:
                break
            elif status == 'stuck':
                # æ£€æŸ¥æ˜¯å¦å¡ä½
                print("ä»»åŠ¡å¯èƒ½å¡ä½ï¼Œå°è¯•é‡å¯...")
                restart_backtest(task_id, api_key)
                
            time.sleep(30)  # 30ç§’æ£€æŸ¥ä¸€æ¬¡
            
        except Exception as e:
            print(f"ç›‘æ§é”™è¯¯: {e}")
            break

def restart_backtest(task_id, api_key):
    """é‡å¯å›æµ‹ä»»åŠ¡"""
    headers = {'Authorization': f'Bearer {api_key}'}
    url = f'https://api.trademaster.ai/v1/backtest/{task_id}/restart'
    
    response = requests.post(url, headers=headers)
    if response.status_code == 200:
        print("å›æµ‹ä»»åŠ¡å·²é‡å¯")
    else:
        print(f"é‡å¯å¤±è´¥: {response.text}")
```

**æ€§èƒ½ä¼˜åŒ–ï¼š**

```yaml
å›æµ‹æ€§èƒ½ä¼˜åŒ–:

å†…å­˜ä¼˜åŒ–:
  1. å‡å°‘æ•°æ®åŠ è½½çª—å£å¤§å°
  2. å¯ç”¨æ•°æ®åˆ†æ‰¹å¤„ç†
  3. æ¸…ç†ä¸å¿…è¦çš„ä¸­é—´å˜é‡
  4. ä½¿ç”¨å†…å­˜æ˜ å°„æ–‡ä»¶

è®¡ç®—ä¼˜åŒ–:
  1. å¯ç”¨GPUåŠ é€Ÿï¼ˆå¦‚å¯ç”¨ï¼‰
  2. ä½¿ç”¨å¤šæ ¸å¹¶è¡Œå¤„ç†
  3. ä¼˜åŒ–ç®—æ³•å¤æ‚åº¦
  4. ç¼“å­˜é‡å¤è®¡ç®—ç»“æœ

æ•°æ®ä¼˜åŒ–:
  1. é¢„å¤„ç†æ•°æ®æ ¼å¼
  2. å»ºç«‹é€‚å½“çš„æ•°æ®ç´¢å¼•
  3. å‹ç¼©å†å²æ•°æ®
  4. ä½¿ç”¨é«˜æ•ˆçš„æ•°æ®æ ¼å¼ï¼ˆå¦‚Parquetï¼‰
```

---

## æ€§èƒ½é—®é¢˜è¯Šæ–­

### ğŸŒ é¡µé¢åŠ è½½ç¼“æ…¢

**æ€§èƒ½ç›‘æ§è„šæœ¬ï¼š**

```javascript
// å‰ç«¯æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
    constructor() {
        this.metrics = {};
    }
    
    // æµ‹é‡é¡µé¢åŠ è½½æ—¶é—´
    measurePageLoad() {
        const perfData = performance.getEntriesByType('navigation')[0];
        
        this.metrics.pageLoad = {
            'DNSæŸ¥è¯¢': perfData.domainLookupEnd - perfData.domainLookupStart,
            'TCPè¿æ¥': perfData.connectEnd - perfData.connectStart,
            'SSLæ¡æ‰‹': perfData.secureConnectionStart ? 
                       perfData.connectEnd - perfData.secureConnectionStart : 0,
            'è¯·æ±‚æ—¶é—´': perfData.responseStart - perfData.requestStart,
            'å“åº”æ—¶é—´': perfData.responseEnd - perfData.responseStart,
            'DOMè§£æ': perfData.domContentLoadedEventEnd - perfData.responseEnd,
            'èµ„æºåŠ è½½': perfData.loadEventStart - perfData.domContentLoadedEventEnd,
            'æ€»åŠ è½½æ—¶é—´': perfData.loadEventEnd - perfData.navigationStart
        };
        
        return this.metrics.pageLoad;
    }
    
    // æµ‹é‡APIè¯·æ±‚æ€§èƒ½
    measureAPIRequest(url, startTime) {
        const endTime = performance.now();
        const duration = endTime - startTime;
        
        if (!this.metrics.apiRequests) {
            this.metrics.apiRequests = [];
        }
        
        this.metrics.apiRequests.push({
            url: url,
            duration: duration,
            timestamp: new Date().toISOString()
        });
        
        // æ€§èƒ½è­¦å‘Š
        if (duration > 3000) {
            console.warn(`APIè¯·æ±‚è¿‡æ…¢: ${url} (${duration}ms)`);
        }
        
        return duration;
    }
    
    // å†…å­˜ä½¿ç”¨ç›‘æ§
    measureMemoryUsage() {
        if ('memory' in performance) {
            this.metrics.memory = {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        
        return this.metrics.memory;
    }
    
    // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    generateReport() {
        console.group('ğŸš€ æ€§èƒ½åˆ†ææŠ¥å‘Š');
        
        if (this.metrics.pageLoad) {
            console.group('ğŸ“„ é¡µé¢åŠ è½½æ€§èƒ½');
            Object.entries(this.metrics.pageLoad).forEach(([key, value]) => {
                const status = value > 1000 ? 'âš ï¸' : value > 500 ? 'ğŸŸ¡' : 'âœ…';
                console.log(`${status} ${key}: ${value.toFixed(2)}ms`);
            });
            console.groupEnd();
        }
        
        if (this.metrics.apiRequests && this.metrics.apiRequests.length > 0) {
            console.group('ğŸ”— APIè¯·æ±‚æ€§èƒ½');
            const avgDuration = this.metrics.apiRequests.reduce((sum, req) => 
                sum + req.duration, 0) / this.metrics.apiRequests.length;
            console.log(`å¹³å‡å“åº”æ—¶é—´: ${avgDuration.toFixed(2)}ms`);
            
            const slowRequests = this.metrics.apiRequests.filter(req => req.duration > 2000);
            if (slowRequests.length > 0) {
                console.warn('æ…¢è¯·æ±‚åˆ—è¡¨:', slowRequests);
            }
            console.groupEnd();
        }
        
        if (this.metrics.memory) {
            console.group('ğŸ’¾ å†…å­˜ä½¿ç”¨æƒ…å†µ');
            const usedMB = (this.metrics.memory.used / 1024 / 1024).toFixed(2);
            const totalMB = (this.metrics.memory.total / 1024 / 1024).toFixed(2);
            console.log(`å·²ä½¿ç”¨: ${usedMB}MB / ${totalMB}MB`);
            console.groupEnd();
        }
        
        console.groupEnd();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor();

// é¡µé¢åŠ è½½å®Œæˆåæµ‹é‡æ€§èƒ½
window.addEventListener('load', () => {
    setTimeout(() => {
        monitor.measurePageLoad();
        monitor.measureMemoryUsage();
        monitor.generateReport();
    }, 1000);
});

// APIè¯·æ±‚æ€§èƒ½ç›‘æ§
const originalFetch = window.fetch;
window.fetch = function(...args) {
    const startTime = performance.now();
    return originalFetch.apply(this, args)
        .then(response => {
            monitor.measureAPIRequest(args[0], startTime);
            return response;
        });
};
```

**æ€§èƒ½ä¼˜åŒ–å»ºè®®ï¼š**

```yaml
å‰ç«¯æ€§èƒ½ä¼˜åŒ–:

èµ„æºä¼˜åŒ–:
  1. å¯ç”¨Gzipå‹ç¼©
  2. ä½¿ç”¨CDNåŠ é€Ÿé™æ€èµ„æº
  3. å‹ç¼©å›¾ç‰‡å’Œé™æ€æ–‡ä»¶
  4. ä½¿ç”¨WebPæ ¼å¼å›¾ç‰‡

ä»£ç ä¼˜åŒ–:
  1. ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
  2. ç§»é™¤æœªä½¿ç”¨çš„ä»£ç 
  3. ä¼˜åŒ–JavaScriptæ‰§è¡Œ
  4. ä½¿ç”¨Web Workerså¤„ç†è®¡ç®—

ç¼“å­˜ç­–ç•¥:
  1. è®¾ç½®é€‚å½“çš„ç¼“å­˜å¤´
  2. ä½¿ç”¨æµè§ˆå™¨æœ¬åœ°å­˜å‚¨
  3. å®ç°æœåŠ¡ç«¯ç¼“å­˜
  4. æ•°æ®åº“æŸ¥è¯¢ç¼“å­˜

ç½‘ç»œä¼˜åŒ–:
  1. å‡å°‘HTTPè¯·æ±‚æ•°é‡
  2. ä½¿ç”¨HTTP/2åè®®
  3. å¯ç”¨Keep-Aliveè¿æ¥
  4. ä¼˜åŒ–DNSè§£æ
```

### ğŸ”¥ CPUä½¿ç”¨ç‡è¿‡é«˜

**æœåŠ¡å™¨ç›‘æ§è„šæœ¬ï¼š**

```bash
#!/bin/bash
# CPUç›‘æ§è„šæœ¬

echo "=== CPUä½¿ç”¨ç‡ç›‘æ§ ==="
echo "æ—¶é—´: $(date)"
echo

# æ•´ä½“CPUä½¿ç”¨æƒ…å†µ
echo "æ•´ä½“CPUä½¿ç”¨ç‡:"
top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//'

# æŒ‰è¿›ç¨‹CPUä½¿ç”¨ç‡æ’åº
echo -e "\nå ç”¨CPUæœ€é«˜çš„è¿›ç¨‹:"
ps aux --sort=-pcpu | head -10

# ç³»ç»Ÿè´Ÿè½½
echo -e "\nç³»ç»Ÿè´Ÿè½½:"
uptime

# CPUæ¸©åº¦ï¼ˆå¦‚æœæ”¯æŒï¼‰
if command -v sensors >/dev/null 2>&1; then
    echo -e "\nCPUæ¸©åº¦:"
    sensors | grep -i "cpu\|core" | grep "Â°C"
fi

# æ£€æŸ¥é«˜CPUä½¿ç”¨çš„Pythonè¿›ç¨‹
echo -e "\nPythonè¿›ç¨‹CPUä½¿ç”¨:"
ps aux | grep python | grep -v grep | awk '{print $3, $11}' | sort -nr

# å†…å­˜ä½¿ç”¨æƒ…å†µ
echo -e "\nå†…å­˜ä½¿ç”¨æƒ…å†µ:"
free -h

# ç£ç›˜I/Oæƒ…å†µ
echo -e "\nç£ç›˜I/O:"
if command -v iostat >/dev/null 2>&1; then
    iostat -x 1 1 | tail -n +4
else
    echo "iostat æœªå®‰è£…ï¼Œè·³è¿‡ç£ç›˜I/Oæ£€æŸ¥"
fi
```

**CPUä¼˜åŒ–æ–¹æ¡ˆï¼š**

```yaml
CPUä¼˜åŒ–ç­–ç•¥:

ä»£ç å±‚é¢:
  1. ä¼˜åŒ–ç®—æ³•å¤æ‚åº¦
  2. ä½¿ç”¨å¹¶è¡Œå¤„ç†
  3. é¿å…ä¸å¿…è¦çš„å¾ªç¯
  4. ç¼“å­˜è®¡ç®—ç»“æœ

ç³»ç»Ÿå±‚é¢:
  1. å¢åŠ CPUæ ¸å¿ƒæ•°
  2. ä¼˜åŒ–è¿›ç¨‹è°ƒåº¦
  3. è°ƒæ•´ç³»ç»Ÿå‚æ•°
  4. ä½¿ç”¨SSDå‡å°‘I/Oç­‰å¾…

åº”ç”¨å±‚é¢:
  1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
  2. ç¼“å­˜çƒ­ç‚¹æ•°æ®
  3. å¼‚æ­¥å¤„ç†ä»»åŠ¡
  4. è´Ÿè½½å‡è¡¡åˆ†å¸ƒ
```

---

## æ•°æ®ç›¸å…³æ•…éšœ

### ğŸ“Š æ•°æ®ä¸Šä¼ å¤±è´¥

**æ•°æ®éªŒè¯è„šæœ¬ï¼š**

```python
import pandas as pd
import numpy as np
from datetime import datetime
import warnings

class DataValidator:
    def __init__(self):
        self.errors = []
        self.warnings = []
    
    def validate_stock_data(self, df):
        """éªŒè¯è‚¡ç¥¨æ•°æ®æ ¼å¼"""
        required_columns = ['date', 'open', 'high', 'low', 'close', 'volume']
        
        # æ£€æŸ¥å¿…éœ€åˆ—
        missing_cols = set(required_columns) - set(df.columns)
        if missing_cols:
            self.errors.append(f"ç¼ºå°‘å¿…éœ€åˆ—: {missing_cols}")
        
        # æ£€æŸ¥æ•°æ®ç±»å‹
        try:
            df['date'] = pd.to_datetime(df['date'])
        except:
            self.errors.append("æ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºYYYY-MM-DDæ ¼å¼")
        
        # æ£€æŸ¥æ•°å€¼åˆ—
        numeric_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in numeric_cols:
            if col in df.columns:
                if not pd.api.types.is_numeric_dtype(df[col]):
                    self.errors.append(f"åˆ— {col} åº”ä¸ºæ•°å€¼ç±»å‹")
                
                # æ£€æŸ¥è´Ÿå€¼
                if (df[col] < 0).any():
                    self.warnings.append(f"åˆ— {col} åŒ…å«è´Ÿå€¼")
        
        # æ£€æŸ¥OHLCé€»è¾‘
        if all(col in df.columns for col in ['open', 'high', 'low', 'close']):
            invalid_ohlc = (
                (df['high'] < df['open']) | 
                (df['high'] < df['close']) |
                (df['low'] > df['open']) | 
                (df['low'] > df['close'])
            )
            if invalid_ohlc.any():
                self.errors.append("å­˜åœ¨ä¸åˆç†çš„OHLCæ•°æ®")
        
        # æ£€æŸ¥é‡å¤æ—¥æœŸ
        if df['date'].duplicated().any():
            self.warnings.append("å­˜åœ¨é‡å¤æ—¥æœŸ")
        
        # æ£€æŸ¥ç¼ºå¤±å€¼
        missing_data = df.isnull().sum()
        if missing_data.any():
            self.warnings.append(f"å­˜åœ¨ç¼ºå¤±å€¼: {missing_data[missing_data > 0].to_dict()}")
        
        return len(self.errors) == 0
    
    def get_validation_report(self):
        """è·å–éªŒè¯æŠ¥å‘Š"""
        report = {"status": "success" if len(self.errors) == 0 else "failed"}
        
        if self.errors:
            report["errors"] = self.errors
        
        if self.warnings:
            report["warnings"] = self.warnings
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
def validate_uploaded_file(file_path):
    try:
        # è¯»å–æ•°æ®
        if file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
        elif file_path.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(file_path)
        else:
            return {"status": "failed", "errors": ["ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼"]}
        
        # éªŒè¯æ•°æ®
        validator = DataValidator()
        is_valid = validator.validate_stock_data(df)
        
        report = validator.get_validation_report()
        report["row_count"] = len(df)
        report["column_count"] = len(df.columns)
        
        return report
        
    except Exception as e:
        return {"status": "failed", "errors": [f"æ–‡ä»¶è¯»å–å¤±è´¥: {str(e)}"]}
```

**æ•°æ®æ ¼å¼æ ‡å‡†åŒ–ï¼š**

```python
def standardize_data_format(df):
    """æ ‡å‡†åŒ–æ•°æ®æ ¼å¼"""
    
    # 1. æ ‡å‡†åŒ–åˆ—å
    column_mapping = {
        'Date': 'date', 'DATE': 'date',
        'Open': 'open', 'OPEN': 'open',
        'High': 'high', 'HIGH': 'high',
        'Low': 'low', 'LOW': 'low',
        'Close': 'close', 'CLOSE': 'close',
        'Volume': 'volume', 'VOLUME': 'volume',
        'Adj Close': 'adj_close'
    }
    df = df.rename(columns=column_mapping)
    
    # 2. æ ‡å‡†åŒ–æ—¥æœŸæ ¼å¼
    df['date'] = pd.to_datetime(df['date'])
    
    # 3. å¤„ç†ç¼ºå¤±å€¼
    df = df.fillna(method='ffill')  # å‰å‘å¡«å……
    
    # 4. æ•°æ®ç±»å‹è½¬æ¢
    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
    for col in numeric_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
    
    # 5. æ’åº
    df = df.sort_values('date').reset_index(drop=True)
    
    # 6. å»é‡
    df = df.drop_duplicates(subset=['date'])
    
    return df
```

### ğŸ”„ æ•°æ®åŒæ­¥é—®é¢˜

**åŒæ­¥çŠ¶æ€æ£€æŸ¥ï¼š**

```python
import requests
import time
from datetime import datetime, timedelta

class DataSyncMonitor:
    def __init__(self, api_key):
        self.api_key = api_key
        self.headers = {'Authorization': f'Bearer {api_key}'}
        self.base_url = 'https://api.trademaster.ai/v1'
    
    def check_sync_status(self, data_source):
        """æ£€æŸ¥æ•°æ®åŒæ­¥çŠ¶æ€"""
        url = f"{self.base_url}/data/sync/status/{data_source}"
        
        try:
            response = requests.get(url, headers=self.headers)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            return {"error": str(e)}
    
    def get_last_update_time(self, data_source):
        """è·å–æœ€åæ›´æ–°æ—¶é—´"""
        url = f"{self.base_url}/data/last_update/{data_source}"
        
        try:
            response = requests.get(url, headers=self.headers)
            response.raise_for_status()
            data = response.json()
            
            last_update = datetime.fromisoformat(data['last_update'])
            now = datetime.now()
            delay = now - last_update
            
            return {
                "last_update": last_update.isoformat(),
                "delay_minutes": delay.total_seconds() / 60,
                "status": "normal" if delay < timedelta(hours=1) else "delayed"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def trigger_manual_sync(self, data_source):
        """æ‰‹åŠ¨è§¦å‘æ•°æ®åŒæ­¥"""
        url = f"{self.base_url}/data/sync/trigger"
        payload = {"data_source": data_source}
        
        try:
            response = requests.post(url, headers=self.headers, json=payload)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": str(e)}
    
    def monitor_sync_health(self):
        """ç›‘æ§æ•°æ®åŒæ­¥å¥åº·çŠ¶æ€"""
        data_sources = ['yahoo_finance', 'alpha_vantage', 'local_db']
        health_report = {}
        
        for source in data_sources:
            status = self.check_sync_status(source)
            update_info = self.get_last_update_time(source)
            
            health_report[source] = {
                "sync_status": status,
                "update_info": update_info,
                "health": "healthy" if not status.get('error') and 
                         update_info.get('status') == 'normal' else "unhealthy"
            }
        
        return health_report

# ä½¿ç”¨ç¤ºä¾‹
monitor = DataSyncMonitor('your_api_key')
health_report = monitor.monitor_sync_health()

for source, info in health_report.items():
    print(f"\nData Source: {source}")
    print(f"Health: {info['health']}")
    if info['health'] == 'unhealthy':
        print("å°è¯•æ‰‹åŠ¨åŒæ­¥...")
        result = monitor.trigger_manual_sync(source)
        print(f"åŒæ­¥ç»“æœ: {result}")
```

---

## APIæ¥å£æ•…éšœ

### ğŸ”Œ APIè¿æ¥é—®é¢˜

**APIå¥åº·æ£€æŸ¥è„šæœ¬ï¼š**

```python
import requests
import time
import json
from datetime import datetime

class APIHealthChecker:
    def __init__(self, base_url, api_key):
        self.base_url = base_url
        self.headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        self.endpoints = {
            'health': '/health',
            'auth': '/auth/verify',
            'data': '/data/stocks',
            'strategy': '/strategy/list',
            'backtest': '/backtest/status'
        }
    
    def check_endpoint(self, endpoint_name, timeout=10):
        """æ£€æŸ¥å•ä¸ªAPIç«¯ç‚¹"""
        url = self.base_url + self.endpoints[endpoint_name]
        
        try:
            start_time = time.time()
            response = requests.get(url, headers=self.headers, timeout=timeout)
            end_time = time.time()
            
            return {
                'endpoint': endpoint_name,
                'url': url,
                'status_code': response.status_code,
                'response_time': round((end_time - start_time) * 1000, 2),
                'success': response.status_code == 200,
                'timestamp': datetime.now().isoformat()
            }
        except requests.exceptions.Timeout:
            return {
                'endpoint': endpoint_name,
                'url': url,
                'error': 'timeout',
                'success': False,
                'timestamp': datetime.now().isoformat()
            }
        except requests.exceptions.ConnectionError:
            return {
                'endpoint': endpoint_name,
                'url': url,
                'error': 'connection_error',
                'success': False,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'endpoint': endpoint_name,
                'url': url,
                'error': str(e),
                'success': False,
                'timestamp': datetime.now().isoformat()
            }
    
    def check_all_endpoints(self):
        """æ£€æŸ¥æ‰€æœ‰APIç«¯ç‚¹"""
        results = []
        
        for endpoint_name in self.endpoints:
            result = self.check_endpoint(endpoint_name)
            results.append(result)
            
            # é¿å…è¿‡å¿«è¯·æ±‚
            time.sleep(0.5)
        
        # ç”Ÿæˆå¥åº·æŠ¥å‘Š
        successful = sum(1 for r in results if r['success'])
        total = len(results)
        
        health_report = {
            'overall_health': 'healthy' if successful == total else 'unhealthy',
            'success_rate': f"{successful}/{total} ({successful/total*100:.1f}%)",
            'timestamp': datetime.now().isoformat(),
            'endpoints': results
        }
        
        return health_report
    
    def continuous_monitoring(self, interval=60, duration=3600):
        """æŒç»­ç›‘æ§APIå¥åº·çŠ¶æ€"""
        print(f"å¼€å§‹APIç›‘æ§ï¼Œé—´éš”{interval}ç§’ï¼ŒæŒç»­{duration}ç§’")
        
        start_time = time.time()
        while time.time() - start_time < duration:
            health_report = self.check_all_endpoints()
            
            print(f"\n[{health_report['timestamp']}]")
            print(f"æ•´ä½“çŠ¶æ€: {health_report['overall_health']}")
            print(f"æˆåŠŸç‡: {health_report['success_rate']}")
            
            # æ˜¾ç¤ºå¤±è´¥çš„ç«¯ç‚¹
            failed_endpoints = [ep for ep in health_report['endpoints'] if not ep['success']]
            if failed_endpoints:
                print("å¤±è´¥ç«¯ç‚¹:")
                for ep in failed_endpoints:
                    print(f"  - {ep['endpoint']}: {ep.get('error', 'unknown error')}")
            
            time.sleep(interval)

# ä½¿ç”¨ç¤ºä¾‹
checker = APIHealthChecker('https://api.trademaster.ai/v1', 'your_api_key')

# å•æ¬¡æ£€æŸ¥
health_report = checker.check_all_endpoints()
print(json.dumps(health_report, indent=2))

# æŒç»­ç›‘æ§ï¼ˆè¿è¡Œ1å°æ—¶ï¼Œæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
# checker.continuous_monitoring(interval=60, duration=3600)
```

### ğŸ“Š APIæ€§èƒ½ç›‘æ§

**æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼š**

```python
import asyncio
import aiohttp
import time
import statistics
from concurrent.futures import ThreadPoolExecutor

class APIPerformanceTester:
    def __init__(self, base_url, api_key):
        self.base_url = base_url
        self.headers = {'Authorization': f'Bearer {api_key}'}
    
    def sync_request_test(self, endpoint, num_requests=10):
        """åŒæ­¥è¯·æ±‚æ€§èƒ½æµ‹è¯•"""
        url = self.base_url + endpoint
        response_times = []
        errors = 0
        
        for i in range(num_requests):
            try:
                start_time = time.time()
                response = requests.get(url, headers=self.headers, timeout=30)
                end_time = time.time()
                
                response_time = (end_time - start_time) * 1000
                response_times.append(response_time)
                
                if response.status_code != 200:
                    errors += 1
                    
            except Exception as e:
                errors += 1
                print(f"è¯·æ±‚ {i+1} å¤±è´¥: {e}")
        
        if response_times:
            return {
                'endpoint': endpoint,
                'requests': num_requests,
                'errors': errors,
                'success_rate': f"{(num_requests-errors)/num_requests*100:.1f}%",
                'avg_response_time': f"{statistics.mean(response_times):.2f}ms",
                'min_response_time': f"{min(response_times):.2f}ms",
                'max_response_time': f"{max(response_times):.2f}ms",
                'median_response_time': f"{statistics.median(response_times):.2f}ms"
            }
        else:
            return {'endpoint': endpoint, 'error': 'æ‰€æœ‰è¯·æ±‚éƒ½å¤±è´¥äº†'}
    
    async def async_request_test(self, endpoint, num_requests=10, concurrency=5):
        """å¼‚æ­¥å¹¶å‘è¯·æ±‚æµ‹è¯•"""
        url = self.base_url + endpoint
        response_times = []
        errors = 0
        
        async def make_request(session):
            try:
                start_time = time.time()
                async with session.get(url, headers=self.headers) as response:
                    await response.text()
                    end_time = time.time()
                    
                    response_time = (end_time - start_time) * 1000
                    response_times.append(response_time)
                    
                    if response.status != 200:
                        nonlocal errors
                        errors += 1
            except Exception as e:
                errors += 1
        
        # åˆ›å»ºä¿¡å·é‡é™åˆ¶å¹¶å‘æ•°
        semaphore = asyncio.Semaphore(concurrency)
        
        async def limited_request(session):
            async with semaphore:
                await make_request(session)
        
        async with aiohttp.ClientSession() as session:
            tasks = [limited_request(session) for _ in range(num_requests)]
            await asyncio.gather(*tasks)
        
        if response_times:
            return {
                'endpoint': endpoint,
                'requests': num_requests,
                'concurrency': concurrency,
                'errors': errors,
                'success_rate': f"{(num_requests-errors)/num_requests*100:.1f}%",
                'avg_response_time': f"{statistics.mean(response_times):.2f}ms",
                'min_response_time': f"{min(response_times):.2f}ms",
                'max_response_time': f"{max(response_times):.2f}ms",
                'median_response_time': f"{statistics.median(response_times):.2f}ms"
            }
        else:
            return {'endpoint': endpoint, 'error': 'æ‰€æœ‰è¯·æ±‚éƒ½å¤±è´¥äº†'}
    
    def load_test(self, endpoint, duration=60, rps=10):
        """è´Ÿè½½æµ‹è¯•"""
        url = self.base_url + endpoint
        
        start_time = time.time()
        request_count = 0
        error_count = 0
        response_times = []
        
        while time.time() - start_time < duration:
            cycle_start = time.time()
            
            for _ in range(rps):
                try:
                    req_start = time.time()
                    response = requests.get(url, headers=self.headers, timeout=10)
                    req_end = time.time()
                    
                    request_count += 1
                    response_times.append((req_end - req_start) * 1000)
                    
                    if response.status_code != 200:
                        error_count += 1
                        
                except Exception:
                    error_count += 1
                    request_count += 1
            
            # æ§åˆ¶è¯·æ±‚é¢‘ç‡
            cycle_time = time.time() - cycle_start
            if cycle_time < 1.0:
                time.sleep(1.0 - cycle_time)
        
        total_time = time.time() - start_time
        
        return {
            'endpoint': endpoint,
            'duration': f"{total_time:.1f}s",
            'total_requests': request_count,
            'total_errors': error_count,
            'requests_per_second': f"{request_count/total_time:.2f}",
            'error_rate': f"{error_count/request_count*100:.1f}%",
            'avg_response_time': f"{statistics.mean(response_times):.2f}ms" if response_times else "N/A"
        }

# ä½¿ç”¨ç¤ºä¾‹
tester = APIPerformanceTester('https://api.trademaster.ai/v1', 'your_api_key')

# åŒæ­¥æ€§èƒ½æµ‹è¯•
print("=== åŒæ­¥è¯·æ±‚æµ‹è¯• ===")
sync_result = tester.sync_request_test('/data/stocks', num_requests=20)
print(json.dumps(sync_result, indent=2))

# å¼‚æ­¥å¹¶å‘æµ‹è¯•
print("\n=== å¼‚æ­¥å¹¶å‘æµ‹è¯• ===")
async_result = asyncio.run(tester.async_request_test('/data/stocks', num_requests=50, concurrency=10))
print(json.dumps(async_result, indent=2))

# è´Ÿè½½æµ‹è¯•
print("\n=== è´Ÿè½½æµ‹è¯• ===")
load_result = tester.load_test('/data/stocks', duration=30, rps=5)
print(json.dumps(load_result, indent=2))
```

---

## éƒ¨ç½²è¿ç»´æ•…éšœ

### ğŸ³ Dockeréƒ¨ç½²é—®é¢˜

**Dockerè¯Šæ–­è„šæœ¬ï¼š**

```bash
#!/bin/bash
# Dockerç¯å¢ƒè¯Šæ–­è„šæœ¬

echo "=== Dockerç¯å¢ƒè¯Šæ–­ ==="
echo "è¯Šæ–­æ—¶é—´: $(date)"
echo

# 1. DockeråŸºç¡€ä¿¡æ¯
echo "1. Dockerç‰ˆæœ¬ä¿¡æ¯:"
docker version
echo

echo "2. Dockerç³»ç»Ÿä¿¡æ¯:"
docker system info
echo

# 3. å®¹å™¨çŠ¶æ€æ£€æŸ¥
echo "3. å®¹å™¨è¿è¡ŒçŠ¶æ€:"
docker ps -a
echo

# 4. é•œåƒåˆ—è¡¨
echo "4. æœ¬åœ°é•œåƒ:"
docker images
echo

# 5. ç½‘ç»œé…ç½®
echo "5. Dockerç½‘ç»œ:"
docker network ls
echo

# 6. å­˜å‚¨å·ä¿¡æ¯
echo "6. Dockerå­˜å‚¨å·:"
docker volume ls
echo

# 7. ç³»ç»Ÿèµ„æºä½¿ç”¨
echo "7. Dockerèµ„æºä½¿ç”¨:"
docker system df
echo

# 8. å®¹å™¨æ—¥å¿—æ£€æŸ¥
echo "8. å®¹å™¨æ—¥å¿—ï¼ˆæœ€è¿‘50è¡Œï¼‰:"
CONTAINERS=$(docker ps --format "table {{.Names}}" | tail -n +2)
for container in $CONTAINERS; do
    echo "--- $container æ—¥å¿— ---"
    docker logs --tail 50 $container
    echo
done

# 9. æ£€æŸ¥ç«¯å£å ç”¨
echo "9. ç«¯å£å ç”¨æƒ…å†µ:"
netstat -tlnp | grep -E ":(80|443|8000|5432|6379)"
echo

# 10. ç£ç›˜ç©ºé—´æ£€æŸ¥
echo "10. ç£ç›˜ç©ºé—´:"
df -h
echo

# 11. å†…å­˜ä½¿ç”¨æƒ…å†µ
echo "11. å†…å­˜ä½¿ç”¨:"
free -h
echo

# 12. DockeræœåŠ¡çŠ¶æ€
echo "12. DockeræœåŠ¡çŠ¶æ€:"
systemctl status docker --no-pager
echo

echo "=== è¯Šæ–­å®Œæˆ ==="
```

**Docker-Composeæ•…éšœæ’é™¤ï¼š**

```yaml
# docker-compose é—®é¢˜æ’æŸ¥æ­¥éª¤

version: '3.8'

services:
  # æ·»åŠ å¥åº·æ£€æŸ¥
  web:
    image: trademaster-web:latest
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
  
  db:
    image: postgres:13
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    environment:
      - POSTGRES_DB=trademaster
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
  
  redis:
    image: redis:6-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

volumes:
  postgres_data:

# æ•…éšœæ’é™¤å‘½ä»¤
# docker-compose config  # éªŒè¯é…ç½®æ–‡ä»¶
# docker-compose up --build  # é‡æ–°æ„å»ºå¹¶å¯åŠ¨
# docker-compose logs -f service_name  # æŸ¥çœ‹ç‰¹å®šæœåŠ¡æ—¥å¿—
# docker-compose restart service_name  # é‡å¯ç‰¹å®šæœåŠ¡
# docker-compose down && docker-compose up -d  # å®Œå…¨é‡å¯
```

### ğŸ”§ ç³»ç»ŸæœåŠ¡æ•…éšœ

**æœåŠ¡çŠ¶æ€ç›‘æ§è„šæœ¬ï¼š**

```bash
#!/bin/bash
# ç³»ç»ŸæœåŠ¡ç›‘æ§è„šæœ¬

SERVICES=("nginx" "postgresql" "redis" "docker" "trademaster-api")

echo "=== ç³»ç»ŸæœåŠ¡çŠ¶æ€ç›‘æ§ ==="
echo "æ£€æŸ¥æ—¶é—´: $(date)"
echo

for service in "${SERVICES[@]}"; do
    echo "æ£€æŸ¥æœåŠ¡: $service"
    
    # æ£€æŸ¥æœåŠ¡çŠ¶æ€
    if systemctl is-active --quiet $service; then
        echo "âœ… $service è¿è¡Œæ­£å¸¸"
        
        # æ˜¾ç¤ºæœåŠ¡ä¿¡æ¯
        echo "   å¯åŠ¨æ—¶é—´: $(systemctl show $service --property=ActiveEnterTimestamp --value)"
        echo "   è¿è¡Œæ—¶é•¿: $(systemctl show $service --property=ActiveEnterTimestampMonotonic --value)"
        
        # æ£€æŸ¥èµ„æºä½¿ç”¨
        if command -v systemctl >/dev/null 2>&1; then
            memory=$(systemctl show $service --property=MemoryCurrent --value)
            if [ "$memory" != "[not set]" ] && [ "$memory" -gt 0 ]; then
                memory_mb=$((memory / 1024 / 1024))
                echo "   å†…å­˜ä½¿ç”¨: ${memory_mb}MB"
            fi
        fi
    else
        echo "âŒ $service æœªè¿è¡Œ"
        
        # å°è¯•å¯åŠ¨æœåŠ¡
        echo "   å°è¯•å¯åŠ¨æœåŠ¡..."
        if sudo systemctl start $service; then
            echo "   âœ… æœåŠ¡å¯åŠ¨æˆåŠŸ"
        else
            echo "   âŒ æœåŠ¡å¯åŠ¨å¤±è´¥"
            echo "   é”™è¯¯æ—¥å¿—:"
            sudo journalctl -u $service --lines=10 --no-pager
        fi
    fi
    
    echo
done

# æ£€æŸ¥ç«¯å£ç›‘å¬
echo "=== ç«¯å£ç›‘å¬çŠ¶æ€ ==="
PORTS=("80" "443" "8000" "5432" "6379")

for port in "${PORTS[@]}"; do
    if netstat -tlnp | grep -q ":$port "; then
        process=$(netstat -tlnp | grep ":$port " | awk '{print $7}' | head -1)
        echo "âœ… ç«¯å£ $port æ­£åœ¨ç›‘å¬ (è¿›ç¨‹: $process)"
    else
        echo "âŒ ç«¯å£ $port æœªç›‘å¬"
    fi
done

echo
echo "=== ç³»ç»Ÿèµ„æºçŠ¶æ€ ==="
echo "CPUä½¿ç”¨ç‡: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')%"
echo "å†…å­˜ä½¿ç”¨: $(free | grep Mem | awk '{printf "%.1f%%", $3/$2 * 100.0}')"
echo "ç£ç›˜ä½¿ç”¨: $(df -h / | awk 'NR==2{printf "%s", $5}')"
echo

echo "=== ç›‘æ§å®Œæˆ ==="
```

---

## æµè§ˆå™¨ç›¸å…³é—®é¢˜

### ğŸŒ å…¼å®¹æ€§é—®é¢˜è§£å†³

**æµè§ˆå™¨å…¼å®¹æ€§æ£€æµ‹ï¼š**

```javascript
// æµè§ˆå™¨å…¼å®¹æ€§æ£€æµ‹å’Œè§£å†³æ–¹æ¡ˆ
class BrowserCompatibilityChecker {
    constructor() {
        this.userAgent = navigator.userAgent;
        this.issues = [];
        this.recommendations = [];
    }
    
    // æ£€æµ‹æµè§ˆå™¨ç±»å‹å’Œç‰ˆæœ¬
    detectBrowser() {
        const browsers = {
            Chrome: /Chrome\/(\d+)/,
            Firefox: /Firefox\/(\d+)/,
            Safari: /Safari\/(\d+)/,
            Edge: /Edg\/(\d+)/,
            IE: /MSIE (\d+)|Trident.*rv:(\d+)/
        };
        
        for (const [name, regex] of Object.entries(browsers)) {
            const match = this.userAgent.match(regex);
            if (match) {
                const version = parseInt(match[1] || match[2]);
                return { name, version };
            }
        }
        
        return { name: 'Unknown', version: 0 };
    }
    
    // æ£€æŸ¥å¿…éœ€åŠŸèƒ½æ”¯æŒ
    checkRequiredFeatures() {
        const features = {
            es6: {
                test: () => typeof Symbol !== 'undefined',
                required: true,
                fallback: 'polyfill'
            },
            fetch: {
                test: () => typeof fetch !== 'undefined',
                required: true,
                fallback: 'axiosæˆ–å…¶ä»–HTTPåº“'
            },
            promise: {
                test: () => typeof Promise !== 'undefined',
                required: true,
                fallback: 'Promise polyfill'
            },
            localStorage: {
                test: () => typeof Storage !== 'undefined',
                required: true,
                fallback: 'Cookieå­˜å‚¨'
            },
            webSocket: {
                test: () => typeof WebSocket !== 'undefined',
                required: false,
                fallback: 'è½®è¯¢æœºåˆ¶'
            },
            canvas: {
                test: () => {
                    const canvas = document.createElement('canvas');
                    return !!(canvas.getContext && canvas.getContext('2d'));
                },
                required: true,
                fallback: 'é™æ€å›¾è¡¨'
            }
        };
        
        const results = {};
        for (const [name, feature] of Object.entries(features)) {
            const supported = feature.test();
            results[name] = {
                supported,
                required: feature.required,
                fallback: feature.fallback
            };
            
            if (feature.required && !supported) {
                this.issues.push(`ç¼ºå°‘å¿…éœ€åŠŸèƒ½: ${name}`);
                this.recommendations.push(`å»ºè®®: ${feature.fallback}`);
            }
        }
        
        return results;
    }
    
    // æ£€æŸ¥æ€§èƒ½ç›¸å…³åŠŸèƒ½
    checkPerformanceFeatures() {
        const features = {
            webWorkers: typeof Worker !== 'undefined',
            webGL: (() => {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                } catch (e) {
                    return false;
                }
            })(),
            indexedDB: typeof indexedDB !== 'undefined',
            serviceWorker: 'serviceWorker' in navigator,
            intersectionObserver: 'IntersectionObserver' in window
        };
        
        return features;
    }
    
    // ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š
    generateCompatibilityReport() {
        const browser = this.detectBrowser();
        const requiredFeatures = this.checkRequiredFeatures();
        const performanceFeatures = this.checkPerformanceFeatures();
        
        // æ£€æŸ¥æµè§ˆå™¨ç‰ˆæœ¬å…¼å®¹æ€§
        const minVersions = {
            Chrome: 80,
            Firefox: 75,
            Safari: 13,
            Edge: 80
        };
        
        const isVersionSupported = browser.version >= (minVersions[browser.name] || 0);
        if (!isVersionSupported) {
            this.issues.push(`æµè§ˆå™¨ç‰ˆæœ¬è¿‡ä½: ${browser.name} ${browser.version}`);
            this.recommendations.push(`è¯·å‡çº§åˆ° ${browser.name} ${minVersions[browser.name]} æˆ–æ›´é«˜ç‰ˆæœ¬`);
        }
        
        // IEæµè§ˆå™¨ç‰¹æ®Šå¤„ç†
        if (browser.name === 'IE') {
            this.issues.push('ä¸æ”¯æŒIEæµè§ˆå™¨');
            this.recommendations.push('è¯·ä½¿ç”¨Chromeã€Firefoxã€Safariæˆ–Edgeæµè§ˆå™¨');
        }
        
        const report = {
            browser,
            isCompatible: this.issues.length === 0,
            issues: this.issues,
            recommendations: this.recommendations,
            features: {
                required: requiredFeatures,
                performance: performanceFeatures
            },
            timestamp: new Date().toISOString()
        };
        
        return report;
    }
    
    // æ˜¾ç¤ºå…¼å®¹æ€§è­¦å‘Š
    showCompatibilityWarning() {
        if (this.issues.length > 0) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #f44336;
                color: white;
                padding: 10px;
                text-align: center;
                z-index: 10000;
                font-family: Arial, sans-serif;
            `;
            
            warningDiv.innerHTML = `
                <h3>æµè§ˆå™¨å…¼å®¹æ€§è­¦å‘Š</h3>
                <p>æ£€æµ‹åˆ°ä»¥ä¸‹é—®é¢˜ï¼š</p>
                <ul style="list-style: none; padding: 0;">
                    ${this.issues.map(issue => `<li>â€¢ ${issue}</li>`).join('')}
                </ul>
                <p>å»ºè®®ï¼š</p>
                <ul style="list-style: none; padding: 0;">
                    ${this.recommendations.map(rec => `<li>â€¢ ${rec}</li>`).join('')}
                </ul>
                <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px;">å…³é—­</button>
            `;
            
            document.body.insertBefore(warningDiv, document.body.firstChild);
        }
    }
}

// è‡ªåŠ¨æ‰§è¡Œå…¼å®¹æ€§æ£€æŸ¥
document.addEventListener('DOMContentLoaded', function() {
    const checker = new BrowserCompatibilityChecker();
    const report = checker.generateCompatibilityReport();
    
    console.group('ğŸ” æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥æŠ¥å‘Š');
    console.log('æµè§ˆå™¨ä¿¡æ¯:', report.browser);
    console.log('å…¼å®¹æ€§çŠ¶æ€:', report.isCompatible ? 'âœ… å…¼å®¹' : 'âŒ ä¸å…¼å®¹');
    
    if (report.issues.length > 0) {
        console.warn('å‘ç°é—®é¢˜:', report.issues);
        console.info('å»ºè®®è§£å†³æ–¹æ¡ˆ:', report.recommendations);
        checker.showCompatibilityWarning();
    }
    
    console.log('åŠŸèƒ½æ”¯æŒæƒ…å†µ:', report.features);
    console.groupEnd();
});
```

### ğŸ§¹ ç¼“å­˜æ¸…ç†å·¥å…·

**æµè§ˆå™¨ç¼“å­˜æ¸…ç†è„šæœ¬ï¼š**

```javascript
// æµè§ˆå™¨ç¼“å­˜æ¸…ç†å·¥å…·
class BrowserCacheCleaner {
    constructor() {
        this.domain = window.location.hostname;
    }
    
    // æ¸…ç†localStorage
    clearLocalStorage() {
        try {
            const items = Object.keys(localStorage);
            items.forEach(key => {
                if (key.includes(this.domain) || key.includes('trademaster')) {
                    localStorage.removeItem(key);
                }
            });
            console.log('âœ… localStorageå·²æ¸…ç†');
            return true;
        } catch (e) {
            console.error('âŒ localStorageæ¸…ç†å¤±è´¥:', e);
            return false;
        }
    }
    
    // æ¸…ç†sessionStorage
    clearSessionStorage() {
        try {
            sessionStorage.clear();
            console.log('âœ… sessionStorageå·²æ¸…ç†');
            return true;
        } catch (e) {
            console.error('âŒ sessionStorageæ¸…ç†å¤±è´¥:', e);
            return false;
        }
    }
    
    // æ¸…ç†IndexedDB
    async clearIndexedDB() {
        if (!('indexedDB' in window)) {
            console.log('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒIndexedDB');
            return false;
        }
        
        try {
            const databases = await indexedDB.databases();
            const deletePromises = databases.map(db => {
                return new Promise((resolve, reject) => {
                    const deleteReq = indexedDB.deleteDatabase(db.name);
                    deleteReq.onsuccess = () => resolve(db.name);
                    deleteReq.onerror = () => reject(deleteReq.error);
                    deleteReq.onblocked = () => reject(new Error('Database deletion blocked'));
                });
            });
            
            await Promise.all(deletePromises);
            console.log('âœ… IndexedDBå·²æ¸…ç†');
            return true;
        } catch (e) {
            console.error('âŒ IndexedDBæ¸…ç†å¤±è´¥:', e);
            return false;
        }
    }
    
    // æ¸…ç†Service Workerç¼“å­˜
    async clearServiceWorkerCache() {
        if (!('serviceWorker' in navigator)) {
            console.log('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒService Worker');
            return false;
        }
        
        try {
            const cacheNames = await caches.keys();
            const deletePromises = cacheNames.map(cacheName => caches.delete(cacheName));
            await Promise.all(deletePromises);
            console.log('âœ… Service Workerç¼“å­˜å·²æ¸…ç†');
            return true;
        } catch (e) {
            console.error('âŒ Service Workerç¼“å­˜æ¸…ç†å¤±è´¥:', e);
            return false;
        }
    }
    
    // æ¸…ç†Cookiesï¼ˆå½“å‰åŸŸåï¼‰
    clearCookies() {
        try {
            const cookies = document.cookie.split(';');
            cookies.forEach(cookie => {
                const eqPos = cookie.indexOf('=');
                const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
                
                // åˆ é™¤å½“å‰åŸŸåå’Œè·¯å¾„çš„cookie
                document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`;
                document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=${this.domain}`;
                document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=.${this.domain}`;
            });
            console.log('âœ… Cookieså·²æ¸…ç†');
            return true;
        } catch (e) {
            console.error('âŒ Cookiesæ¸…ç†å¤±è´¥:', e);
            return false;
        }
    }
    
    // æ¸…ç†æ‰€æœ‰ç¼“å­˜
    async clearAllCache() {
        console.log('ğŸ§¹ å¼€å§‹æ¸…ç†æµè§ˆå™¨ç¼“å­˜...');
        
        const results = {
            localStorage: this.clearLocalStorage(),
            sessionStorage: this.clearSessionStorage(),
            cookies: this.clearCookies(),
            indexedDB: await this.clearIndexedDB(),
            serviceWorkerCache: await this.clearServiceWorkerCache()
        };
        
        const successCount = Object.values(results).filter(Boolean).length;
        const totalCount = Object.keys(results).length;
        
        console.log(`ğŸ‰ ç¼“å­˜æ¸…ç†å®Œæˆï¼æˆåŠŸï¼š${successCount}/${totalCount}`);
        
        // æ˜¾ç¤ºæ¸…ç†ç»“æœ
        this.showClearResult(results);
        
        return results;
    }
    
    // æ˜¾ç¤ºæ¸…ç†ç»“æœ
    showClearResult(results) {
        const resultDiv = document.createElement('div');
        resultDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: Arial, sans-serif;
            max-width: 300px;
        `;
        
        const successCount = Object.values(results).filter(Boolean).length;
        const totalCount = Object.keys(results).length;
        
        resultDiv.innerHTML = `
            <h3 style="margin: 0 0 10px 0; color: #333;">ç¼“å­˜æ¸…ç†ç»“æœ</h3>
            <p style="margin: 0 0 10px 0;">æˆåŠŸï¼š${successCount}/${totalCount}</p>
            <ul style="margin: 0; padding-left: 20px; font-size: 14px;">
                ${Object.entries(results).map(([key, success]) => 
                    `<li style="color: ${success ? '#4CAF50' : '#f44336'};">
                        ${success ? 'âœ…' : 'âŒ'} ${key}
                    </li>`
                ).join('')}
            </ul>
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="location.reload()" style="padding: 8px 15px; margin-right: 5px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">åˆ·æ–°é¡µé¢</button>
                <button onclick="this.parentElement.parentElement.remove()" style="padding: 8px 15px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">å…³é—­</button>
            </div>
        `;
        
        document.body.appendChild(resultDiv);
        
        // 5ç§’åè‡ªåŠ¨å…³é—­
        setTimeout(() => {
            if (resultDiv.parentElement) {
                resultDiv.remove();
            }
        }, 5000);
    }
    
    // åˆ›å»ºæ¸…ç†æŒ‰é’®
    createClearButton() {
        const button = document.createElement('button');
        button.textContent = 'ğŸ§¹ æ¸…ç†ç¼“å­˜';
        button.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 9999;
            transition: background 0.3s;
        `;
        
        button.addEventListener('mouseenter', () => {
            button.style.background = '#f57c00';
        });
        
        button.addEventListener('mouseleave', () => {
            button.style.background = '#ff9800';
        });
        
        button.addEventListener('click', () => {
            this.clearAllCache();
        });
        
        document.body.appendChild(button);
    }
}

// åˆ›å»ºå…¨å±€æ¸…ç†å·¥å…·å®ä¾‹
window.cacheCleaner = new BrowserCacheCleaner();

// å¼€å‘æ¨¡å¼ä¸‹è‡ªåŠ¨åˆ›å»ºæ¸…ç†æŒ‰é’®
if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
    document.addEventListener('DOMContentLoaded', () => {
        window.cacheCleaner.createClearButton();
    });
}

// æ§åˆ¶å°å‘½ä»¤
console.log('ğŸ’¡ å¯ç”¨å‘½ä»¤ï¼š');
console.log('  - cacheCleaner.clearAllCache() // æ¸…ç†æ‰€æœ‰ç¼“å­˜');
console.log('  - cacheCleaner.clearLocalStorage() // æ¸…ç†localStorage');
console.log('  - cacheCleaner.clearCookies() // æ¸…ç†Cookies');
```

---

## ğŸš¨ ç´§æ€¥æ•…éšœå¤„ç†

### æ€¥æ•‘æ“ä½œæ‰‹å†Œ

```yaml
ç´§æ€¥æ•…éšœå¿«é€Ÿå“åº”:

ç³»ç»Ÿå®Œå…¨ä¸å¯è®¿é—®:
  ç«‹å³è¡ŒåŠ¨:
    1. æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒDNSè§£æ
    2. ç¡®è®¤æœåŠ¡å™¨çŠ¶æ€å’Œè´Ÿè½½å‡è¡¡
    3. æŸ¥çœ‹ç›‘æ§å‘Šè­¦å’Œæ—¥å¿—
    4. è”ç³»è¿ç»´å›¢é˜Ÿå’ŒæŠ€æœ¯è´Ÿè´£äºº
  
  æ¢å¤æ­¥éª¤:
    1. åˆ‡æ¢åˆ°å¤‡ç”¨ç³»ç»Ÿï¼ˆå¦‚æœ‰ï¼‰
    2. é‡å¯ç›¸å…³æœåŠ¡
    3. æ•°æ®åº“è¿æ¥æ£€æŸ¥
    4. ç¼“å­˜æœåŠ¡é‡å¯

æ•°æ®ä¸¢å¤±æˆ–æŸå:
  ç´§æ€¥æªæ–½:
    1. ç«‹å³åœæ­¢ç›¸å…³æ“ä½œ
    2. éš”ç¦»å—å½±å“çš„æ•°æ®
    3. å¯åŠ¨æ•°æ®æ¢å¤ç¨‹åº
    4. é€šçŸ¥ç›¸å…³ç”¨æˆ·
  
  æ¢å¤æµç¨‹:
    1. ä»æœ€è¿‘å¤‡ä»½æ¢å¤
    2. éªŒè¯æ•°æ®å®Œæ•´æ€§
    3. é€æ­¥æ¢å¤æœåŠ¡
    4. è¿›è¡Œå…¨é¢æµ‹è¯•

å®‰å…¨æ¼æ´å¨èƒ:
  åº”æ€¥å“åº”:
    1. ç«‹å³é˜»æ–­æ¶æ„è®¿é—®
    2. æ›´æ”¹ç›¸å…³å¯†ç å’Œå¯†é’¥
    3. å¤‡ä»½ç³»ç»Ÿæ—¥å¿—
    4. è”ç³»å®‰å…¨å›¢é˜Ÿ
  
  ä¿®å¤æªæ–½:
    1. åº”ç”¨å®‰å…¨è¡¥ä¸
    2. åŠ å¼ºè®¿é—®æ§åˆ¶
    3. ç›‘æ§å¼‚å¸¸æ´»åŠ¨
    4. è¿›è¡Œå®‰å…¨å®¡è®¡
```

### ğŸ“ ç´§æ€¥è”ç³»æ–¹å¼

```yaml
ç´§æ€¥è”ç³»ä¿¡æ¯:

æŠ€æœ¯æ”¯æŒ:
  - 24/7æŠ€æœ¯çƒ­çº¿: 400-xxx-xxxx
  - ç´§æ€¥é‚®ç®±: emergency@trademaster.ai
  - æŠ€æœ¯è´Ÿè´£äºº: +86-138-xxxx-xxxx
  - è¿ç»´å›¢é˜Ÿç¾¤: å¾®ä¿¡ç¾¤"TradeMasterè¿ç»´"

åœ¨çº¿æ”¯æŒ:
  - åœ¨çº¿å®¢æœ: ç½‘ç«™å³ä¸‹è§’èŠå¤©çª—å£
  - å·¥å•ç³»ç»Ÿ: https://support.trademaster.ai
  - è¿œç¨‹ååŠ©: TeamViewer IDä¼šæä¾›

ç¤¾åŒºæ”¯æŒ:
  - ç”¨æˆ·è®ºå›: https://forum.trademaster.ai
  - å¼€å‘è€…ç¾¤: QQç¾¤ 456789123
  - æŠ€æœ¯äº¤æµç¾¤: å¾®ä¿¡ç¾¤"TradeMasteræŠ€æœ¯äº¤æµ"
```

---

## ğŸ“Š æ•…éšœæŠ¥å‘Šæ¨¡æ¿

å½“é‡åˆ°é—®é¢˜æ—¶ï¼Œè¯·æŒ‰ä»¥ä¸‹æ ¼å¼æäº¤è¯¦ç»†çš„æ•…éšœæŠ¥å‘Šï¼š

```yaml
æ•…éšœæŠ¥å‘Š:

åŸºæœ¬ä¿¡æ¯:
  - æŠ¥å‘Šæ—¶é—´: [YYYY-MM-DD HH:MM:SS]
  - ç”¨æˆ·è´¦å·: [your_username]
  - ç”¨æˆ·è§’è‰²: [Admin/User/Analyst/Viewer]
  - è”ç³»æ–¹å¼: [email/phone]

é—®é¢˜æè¿°:
  - é—®é¢˜æ ‡é¢˜: [ç®€æ´æè¿°é—®é¢˜]
  - è¯¦ç»†æè¿°: [è¯¦ç»†æè¿°é—®é¢˜ç°è±¡]
  - å½±å“èŒƒå›´: [ä¸ªäºº/éƒ¨é—¨/å…¨ç³»ç»Ÿ]
  - ç´§æ€¥ç¨‹åº¦: [P0/P1/P2/P3]

ç¯å¢ƒä¿¡æ¯:
  - æ“ä½œç³»ç»Ÿ: [Windows 10/macOS 11/Ubuntu 20.04]
  - æµè§ˆå™¨: [Chrome 91.0.4472.124]
  - ç³»ç»Ÿç‰ˆæœ¬: [v1.0.0]
  - ç½‘ç»œç¯å¢ƒ: [å…¬å¸å†…ç½‘/å®¶åº­ç½‘ç»œ/ç§»åŠ¨ç½‘ç»œ]

é‡ç°æ­¥éª¤:
  1. [ç¬¬ä¸€æ­¥æ“ä½œ]
  2. [ç¬¬äºŒæ­¥æ“ä½œ]
  3. [ç¬¬ä¸‰æ­¥æ“ä½œ]
  4. [é—®é¢˜å‡ºç°]

é”™è¯¯ä¿¡æ¯:
  - é”™è¯¯ä»£ç : [å¦‚æœæœ‰]
  - é”™è¯¯æ¶ˆæ¯: [å®Œæ•´é”™è¯¯ä¿¡æ¯]
  - æ§åˆ¶å°æ—¥å¿—: [æµè§ˆå™¨F12æ§åˆ¶å°ä¿¡æ¯]

å·²å°è¯•è§£å†³æ–¹æ¡ˆ:
  - [å·²å°è¯•çš„è§£å†³æ–¹æ³•1] âœ…/âŒ
  - [å·²å°è¯•çš„è§£å†³æ–¹æ³•2] âœ…/âŒ
  - [å·²å°è¯•çš„è§£å†³æ–¹æ³•3] âœ…/âŒ

é™„ä»¶:
  - é”™è¯¯æˆªå›¾: [screenshot.png]
  - æ§åˆ¶å°æ—¥å¿—: [console.log]
  - ç›¸å…³æ–‡ä»¶: [data.csv]
```

---

## ğŸ¯ é¢„é˜²æ€§ç»´æŠ¤

### å®šæœŸæ£€æŸ¥æ¸…å•

```yaml
æ—¥å¸¸æ£€æŸ¥ (æ¯æ—¥):
  âœ… ç³»ç»ŸåŸºæœ¬åŠŸèƒ½æµ‹è¯•
  âœ… æœåŠ¡è¿è¡ŒçŠ¶æ€ç¡®è®¤
  âœ… é”™è¯¯æ—¥å¿—æŸ¥çœ‹
  âœ… ç³»ç»Ÿèµ„æºç›‘æ§

å‘¨åº¦æ£€æŸ¥ (æ¯å‘¨):
  âœ… æ€§èƒ½æŒ‡æ ‡åˆ†æ
  âœ… æ•°æ®å¤‡ä»½éªŒè¯
  âœ… å®‰å…¨æ‰«ææ‰§è¡Œ
  âœ… ç”¨æˆ·åé¦ˆå¤„ç†

æœˆåº¦æ£€æŸ¥ (æ¯æœˆ):
  âœ… ç³»ç»Ÿæ·±åº¦ä½“æ£€
  âœ… ä¾èµ–ç»„ä»¶æ›´æ–°
  âœ… å®¹é‡è§„åˆ’è¯„ä¼°
  âœ… ç¾éš¾æ¢å¤æµ‹è¯•

å­£åº¦æ£€æŸ¥ (æ¯å­£åº¦):
  âœ… æ¶æ„ä¼˜åŒ–è¯„ä¼°
  âœ… å®‰å…¨ç­–ç•¥æ›´æ–°
  âœ… ä¸šåŠ¡è¿ç»­æ€§è®¡åˆ’æµ‹è¯•
  âœ… æŠ€æœ¯å€ºåŠ¡æ¸…ç†
```

é€šè¿‡æœ¬æ•…éšœæ’é™¤æŒ‡å—ï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿç³»ç»Ÿæ€§åœ°è¯Šæ–­å’Œè§£å†³TradeMaster Web Interfaceçš„å„ç§é—®é¢˜ã€‚å¦‚æœé—®é¢˜ä»æœªè§£å†³ï¼Œè¯·ä¸è¦çŠ¹è±«è”ç³»æˆ‘ä»¬çš„æŠ€æœ¯æ”¯æŒå›¢é˜Ÿã€‚

---

ğŸ“… **æœ€åæ›´æ–°**ï¼š2025å¹´8æœˆ15æ—¥  
ğŸ“ **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0.0  
ğŸ‘¥ **ç»´æŠ¤å›¢é˜Ÿ**ï¼šTradeMasteræŠ€æœ¯æ”¯æŒå›¢é˜Ÿ